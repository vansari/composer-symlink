<?php
declare (strict_types = 1);

namespace tools;

use Composer\Composer;
use Composer\Config;
use Composer\Package\Package;
use Composer\Script\Event;
use InvalidArgumentException;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use Throwable;
use TypeError;

/**
 * Class SymlinkerTest
 * @package tools
 * @coversDefaultClass \tools\Symlinker
 */
class SymlinkerTest extends TestCase {

    private static $created = [];
    private static $testPath;

    public function getRelativePath(): array {
        return [
            [
                'origin' => 'foo',
                'destination' => [
                    'bar/foo',
                ],
            ],
            [
                'origin' => 'bar/fooz',
                'destination' => ['fooz'],
            ],
            [
                'origin' => 'bar/foor',
                'destination' => [
                    'foo/baz/bar/foor',
                    'foo/baz/bar2/foor',
                ],
            ],
            [
                'origin' => 'bar/baz/foow',
                'destination' => ['foo/baz/bar/foo_link'],
            ],
            [
                'origin' => 'bar/baz/foow/test.txt',
                'destination' => ['foo/baz/bar/test.txt'],
                true,
            ],
            [
                'origin' => 'bar/baz/foow/test.txt',
                'destination' => [
                    'foo/baz/bar/test_link.txt',
                    'foo/baz/test.txt',
                ],
                true,
            ],
        ];
    }

    public static function setUpBeforeClass(): void {
        parent::setUpBeforeClass(); // TODO: Change the autogenerated stub
        self::$testPath = dirname(__FILE__)
            . DIRECTORY_SEPARATOR
            . uniqid('testdir_')
            . DIRECTORY_SEPARATOR;
    }

    public static function tearDownAfterClass(): void {
        parent::tearDownAfterClass(); // TODO: Change the autogenerated stub
        self::deleteDirectory(self::$testPath);
    }

    /**
     * @covers ::createSymbolicLink
     * @dataProvider getRelativePath
     * @param string $origin
     * @param array $destinations
     * @param bool $isFile
     */
    public function testCreateSymbolicLinkRelative(
        string $origin,
        array $destinations,
        bool $isFile = false
    ): void {
        if (Symlinker::isWindows()) {
            $this->markTestSkipped('No symbolic links with relative Path supported on WIN.');
        }
        $this->createTestSources($origin, $isFile);
        foreach ($destinations as $destination) {
            Symlinker::createSymbolicLink(
                self::$testPath . $origin,
                self::$testPath . $destination,
                Symlinker::RELATIVE_SYMLINK
            );
                $this->assertTrue(is_link(self::$testPath . $destination));
        }
    }

    /**
     * @covers ::createSymbolicLink
     * @dataProvider getRelativePath
     * @param string $origin
     * @param array $destinations
     * @param bool $isFile
     */
    public function testCreateSymbolicLinkAbsolute(
        string $origin,
        array $destinations,
        bool $isFile = false
    ): void {
        $this->createTestSources($origin, $isFile);
        foreach ($destinations as $destination) {
            Symlinker::createSymbolicLink(
                self::$testPath . $origin,
                self::$testPath . $destination,
                Symlinker::ABSOLUTE_SYMLINK
            );
            if (Symlinker::isWindows()) {
                $this->assertTrue(is_dir(self::$testPath . $destination));
            } else {
                $this->assertTrue(is_link(self::$testPath . $destination));
            }
        }
    }

    /**
     * @covers ::createSymbolicLink
     * @dataProvider getRelativePath
     * @param string $origin
     * @param array $destinations
     * @param bool $isFile
     */
    public function testCreateSymbolicLinkDefault(
        string $origin,
        array $destinations,
        bool $isFile = false
    ): void {
        $this->createTestSources($origin, $isFile);
        foreach ($destinations as $destination) {
            Symlinker::createSymbolicLink(
                self::$testPath . $origin,
                self::$testPath . $destination
            );
            if (Symlinker::isWindows()) {
                $this->assertTrue(is_dir(self::$testPath . $destination));
            } else {
                $this->assertTrue(is_link(self::$testPath . $destination));
            }
        }
    }

    /**
     * @covers ::createSymbolicLink
     */
    public function testCreateSymbolicLinkThrowExceptionWithInvalidTypes(): void {
        try {
            Symlinker::createSymbolicLink('foo/bar', 'foo/baz/bar', 'ler');
            $this->fail('Did not throw the expected Exception!');
        } catch (Throwable $exception) {
            $this->assertInstanceOf(InvalidArgumentException::class, $exception);
        }
        try {
            Symlinker::createSymbolicLink('foo/bar', 'foo/baz/bar', '');
            $this->fail('Did not throw the expected Exception!');
        } catch (Throwable $exception) {
            $this->assertInstanceOf(InvalidArgumentException::class, $exception);
        }
        try {
            Symlinker::createSymbolicLink('foo/bar', 'foo/baz/bar', 0);
            $this->fail('Did not throw the expected Exception!');
        } catch (Throwable $exception) {
            $this->assertInstanceOf(TypeError::class, $exception);
        }
    }

    /**
     * Test the correct throwing of the exception if origin path is empty
     */
    public function testCreateSymbolicLinkThrowExceptionWithEmptyOriginPath(): void {
        $this->expectException(InvalidArgumentException::class);
        Symlinker::createSymbolicLink('', dirname(__FILE__));
    }

    /**
     * Test the correct throwing of the exception if destination path is empty
     */
    public function testCreateSymbolicLinkThrowExceptionWithEmptyDestinationPath(): void {
        $this->expectException(InvalidArgumentException::class);
        Symlinker::createSymbolicLink(dirname(__FILE__), '');
    }

    /**
     * @covers       ::createSymlinks
     * @dataProvider getRelativePath
     * @param string $origin
     * @param array $destinations
     * @param bool $isFile
     */
    public function testCreateSymlinksRelative(
        string $origin,
        array $destinations,
        bool $isFile = false
    ): void {
        if (Symlinker::isWindows()) {
            $this->markTestSkipped('No symbolic links with relative Path supported on WIN.');
        }
        $this->createTestSources($origin, $isFile);
        $eventMock = $this->getMock($origin, $destinations, 'rel');

        /** @var Event $eventMock */
        Symlinker::createSymlinks($eventMock);

        foreach ($destinations as $destination) {
            $this->assertTrue(is_link(self::$testPath . $destination));
        }
    }

    /**
     * @covers       ::createSymlinks
     * @dataProvider getRelativePath
     * @param string $origin
     * @param array $destinations
     * @param bool $isFile
     */
    public function testCreateSymlinksAbsolute(
        string $origin,
        array $destinations,
        bool $isFile = false
    ): void {
        $this->createTestSources($origin, $isFile);
        $eventMock = $this->getMock($origin, $destinations, 'abs');

        /** @var Event $eventMock */
        Symlinker::createSymlinks($eventMock);

        foreach ($destinations as $destination) {
            if (Symlinker::isWindows()) {
                $this->assertTrue(
                    (
                        $isFile
                            ? is_file(self::$testPath . $destination)
                            : is_dir(self::$testPath . $destination)
                    )
                );
            } else {
                $this->assertTrue(is_link(self::$testPath . $destination));
            }
        }
    }

    /**
     * @param string $origin
     * @param array $destination
     * @param string|null $type
     * @return MockObject
     */
    private function getMock(
        string $origin,
        array $destination,
        ?string $type = null
    ): MockObject {
        $configMock = $this->getMockBuilder(Config::class)
            ->disableOriginalConstructor()
            ->onlyMethods(
                [
                    'get',
                ]
            )
            ->getMock();

        $configMock
            ->method('get')
            ->with('vendor-dir')
            ->willReturn(self::$testPath . 'vendor');

        $packageMock = $this->getMockBuilder(Package::class)
            ->disableOriginalConstructor()
            ->onlyMethods(
                [
                    'getExtra',
                ]
            )
            ->getMock();
        $destination = [
            $type ?? 0 => $destination,
        ];
        $packageMock
            ->method('getExtra')
            ->willReturn(
                [
                    'symlinks' => [
                        $origin => $destination,
                    ],
                ]
            );

        $composerMock = $this->getMockBuilder(Composer::class)
            ->disableOriginalConstructor()
            ->onlyMethods(
                [
                    'getConfig',
                    'getPackage',
                ]
            )
            ->getMock();

        $composerMock
            ->method('getConfig')
            ->willReturn($configMock);

        $composerMock
            ->method('getPackage')
            ->willReturn($packageMock);

        $eventMock = $this->getMockBuilder(Event::class)
            ->disableOriginalConstructor()
            ->onlyMethods(
                [
                    'getComposer',
                ]
            )
            ->getMock();
        $eventMock
            ->method('getComposer')
            ->willReturn($composerMock);

        return $eventMock;
    }

    /**
     * Löscht die Testverzeichnisse und Testdateien
     * @param string $dir
     */
    private static function deleteDirectory(string $dir): void {
        if (is_dir($dir)) {
            $handle = opendir($dir);
            if (false !== $handle) {
                while (false !== ($file = readdir($handle))) {
                    if (in_array($file, ['.', '..'])) {
                        continue;
                    }
                    $path = $dir . DIRECTORY_SEPARATOR . $file;
                    if (!is_link($path) && is_dir($path)) {
                        self::deleteDirectory($path);
                        continue;
                    }
                    if (is_file($path) || is_link($path)) {
                        unlink($path);
                    }
                }
                closedir($handle);
            }
            rmdir($dir);
        }
    }

    /**
     * @param string $origin
     * @param bool $isFile
     */
    private function createTestSources(string $origin, bool $isFile): void {
        $testDir = self::$testPath . $origin;
        if (!$isFile && !is_dir($testDir)) {
            mkdir($testDir, 0777, true);
            self::$created[] = $testDir;
        }
        if ($isFile) {
            touch($testDir);
            self::$created[] = $testDir;
        }
    }

}
